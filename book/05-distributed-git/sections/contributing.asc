[[_contributing_project]]
=== Contribuyendo a un Proyecto

(((contributing)))
La principal dificultad con la descripción de cómo contribuir a un proyecto es que hay una gran cantidad de variaciones sobre cómo se hace.
Debido a que Git es muy flexible, las personas pueden y trabajan juntas de muchas maneras, y es problemático describir cómo debe contribuir: cada proyecto es un poco diferente.
Algunas de las variables involucradas son conteo de contribuyentes activos, flujo de trabajo elegido, acceso de confirmación y posiblemente el método de contribución externa.

La primera variable es el conteo de contribuyentes activos: ¿cuántos usuarios están contribuyendo activamente al código de este proyecto y con qué frecuencia?
En muchos casos, tendrá dos o tres desarrolladores con algunos commits por día, o posiblemente menos para proyectos un tanto inactivos.
Para empresas o proyectos más grandes, la cantidad de desarrolladores podría ser de miles, con cientos o miles de compromisos cada día.
Esto es importante porque con más y más desarrolladores, se encontrará con más problemas para asegurarse de que su código se aplique de forma limpia o se pueda fusionar fácilmente.
Los cambios que envíe pueden quedar obsoletos o severamente interrumpidos por el trabajo que se fusionó mientras estaba trabajando o mientras los cambios estaban esperando ser aprobados o aplicados.
¿Cómo puede mantener su código constantemente actualizado y sus confirmaciones válidas?

La siguiente variable es el flujo de trabajo en uso para el proyecto.
¿Está centralizado, con cada desarrollador teniendo el mismo acceso de escritura a la línea de código principal?
¿El proyecto tiene un mantenedor o un gerente de integración que verifica todos los parches?
¿Están todos los parches revisados por pares y aprobados?
¿Estás involucrado en ese proceso?
¿Hay un sistema de tenientes en su lugar, y tienes que enviar tu trabajo primero?

El siguiente problema es tu acceso de confirmación.
El flujo de trabajo requerido para contribuir a un proyecto es muy diferente si tiene acceso de escritura al proyecto que si no lo hace.
Si no tiene acceso de escritura, ¿cómo prefiere el proyecto aceptar el trabajo contribuido?
¿Incluso tiene una política?
¿Cuánto trabajo estás contribuyendo a la vez?
¿Con qué frecuencia contribuyes?

Todas estas preguntas pueden afectar la forma en que contribuye de manera efectiva a un proyecto y los flujos de trabajo preferidos o disponibles para usted.
Cubriremos aspectos de cada uno de estos en una serie de casos de uso, pasando de simples a más complejos; debería poder construir los flujos de trabajo específicos que necesita en la práctica a partir de estos ejemplos.

[[_commit_guidelines]]
==== Pautas de confirmación

Antes de comenzar a buscar casos de uso específicos, aquí hay una nota rápida sobre los mensajes de confirmación.
Tener una buena guía para crear compromisos y apegarse a ella hace que trabajar con Git y colaborar con otros sea mucho más fácil.
El proyecto Git proporciona un documento que presenta una serie de buenos consejos para crear compromisos a partir de los cuales enviar parches: puede leerlos en el código fuente de Git en el archivo `Documentation / SubmittingPatches`.

(((git commands, diff, check)))
En primer lugar, no desea enviar ningún error de espacios en blanco.
Git proporciona una manera fácil de verificar esto: antes de comprometerse, ejecute `git diff --check`, que identifica posibles errores de espacio en blanco y los enumera por usted.

.Output of `git diff --check`.
image::images/git-diff-check.png[Output of `git diff --check`.]

Si ejecuta ese comando antes de confirmar, puede ver si está a punto de cometer problemas de espacio en blanco que pueden molestar a otros desarrolladores.

A continuación, intente hacer que cada commit un conjunto de cambios lógicamente separado.
Si puede, trate de hacer que sus cambios sean digeribles: no codifique durante un fin de semana entero en cinco asuntos diferentes y luego envíelos todos como un compromiso masivo el lunes.
Incluso si no confirmas durante el fin de semana, utilice el área de etapas el lunes para dividir su trabajo en al menos una confirmación por cuestión, con un mensaje útil por confirmación.
Si algunos de los cambios modifican el mismo archivo, intente utilizar `git add --patch` para representar parcialmente los archivos (se detalla en << _ interactive_staging >>).
La instantánea del proyecto en la punta de la sucursal es idéntica ya sea que realice una confirmación o cinco, siempre que todos los cambios se agreguen en algún momento, así que trate de facilitar las cosas a sus compañeros desarrolladores cuando tengan que revisar sus cambios.
Este enfoque también hace que sea más fácil retirar o revertir uno de los conjuntos de cambios si lo necesita más adelante.
<< _ rewriting_history >> describe una serie de útiles trucos de Git para reescribir el historial y organizar de forma interactiva los archivos: use estas herramientas para crear un historial limpio y comprensible antes de enviar el trabajo a otra persona.

Lo último a tener en cuenta es el mensaje de compromiso.
Tener el hábito de crear mensajes de compromiso de calidad hace que usar y colaborar con Git sea mucho más fácil.
Como regla general, sus mensajes deben comenzar con una sola línea que no supere los 50 caracteres y que describa el conjunto de cambios de forma concisa, seguido de una línea en blanco, seguida de una explicación más detallada.
El proyecto Git requiere que la explicación más detallada incluya su motivación para el cambio y contraste su implementación con el comportamiento anterior: esta es una buena guía a seguir.
También es una buena idea usar el tiempo presente imperativo en estos mensajes.
En otras palabras, use comandos.
En lugar de `` agregué pruebas para '' o `` Añadir pruebas para '', use `` Agregar pruebas para ''.
Aquí hay una plantilla escrita originalmente por Tim Pope:

[source,text]
-----
Resumen de cambios cortos (50 caracteres o menos)

Texto explicativo más detallado, si es necesario. Ajustarlo a
aproximadamente 72 caracteres más o menos. En algunos contextos, el primero
línea se trata como el tema de un correo electrónico y el resto de
el texto como el cuerpo. La línea en blanco que separa el
resumen del cuerpo es crítico (a menos que omita el cuerpo
enteramente); herramientas como rebase pueden confundirse si ejecuta
los dos juntos.

Otros párrafos vienen después de las líneas en blanco.

  - Los puntos de viñetas también están bien

  - Típicamente se usa un guión o asterisco para la viñeta,
    precedido por un solo espacio, con líneas en blanco
    entre, pero las convenciones varían aquí
-----

Si todos sus mensajes de confirmación se ven así, las cosas serán mucho más fáciles para usted y para los desarrolladores con los que trabaja.
El proyecto Git tiene mensajes de confirmación bien formateados. Intenta ejecutar `git log --no-merges` allí para ver cómo se ve un historial de commit de proyecto muy bien formateado.

En los siguientes ejemplos, y en la mayor parte de este libro, en aras de la brevedad, este libro no tiene mensajes con un formato agradable como este; en cambio, usamos la opción `-m` para` git commit`.
Haz lo que decimos, no como lo hacemos.

[[_private_team]]
==== Pequeño equipo privado

(((contributing, private small team)))
La configuración más simple que es probable que encuentre es un proyecto privado con uno o dos desarrolladores más.
`` Privado '', en este contexto, significa fuente cerrada, no accesible para el mundo exterior.
Usted y los demás desarrolladores tienen acceso de inserción al repositorio.

In this environment, you can follow a workflow similar to what you might do when using Subversion or another centralized system.
You still get the advantages of things like offline committing and vastly simpler branching and merging, but the workflow can be very similar; the main difference is that merges happen client-side rather than on the server at commit time.
Let's see what it might look like when two developers start to work together with a shared repository.
The first developer, John, clones the repository, makes a change, and commits locally.
(The protocol messages have been replaced with `...` in these examples to shorten them somewhat.)

[source,console]
-----
# John's Machine
$ git clone john@githost:simplegit.git
Initialized empty Git repository in /home/john/simplegit/.git/
...
$ cd simplegit/
$ vim lib/simplegit.rb
$ git commit -am 'removed invalid default value'
[master 738ee87] removed invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)
-----

The second developer, Jessica, does the same thing – clones the repository and commits a change:

[source,console]
-----
# Jessica's Machine
$ git clone jessica@githost:simplegit.git
Initialized empty Git repository in /home/jessica/simplegit/.git/
...
$ cd simplegit/
$ vim TODO
$ git commit -am 'add reset task'
[master fbff5bc] add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)
-----

Now, Jessica pushes her work up to the server:

[source,console]
-----
# Jessica's Machine
$ git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -> master
-----

John tries to push his change up, too:

[source,console]
-----
# John's Machine
$ git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -> master (non-fast forward)
error: failed to push some refs to 'john@githost:simplegit.git'
-----

John isn't allowed to push because Jessica has pushed in the meantime.
This is especially important to understand if you're used to Subversion, because you'll notice that the two developers didn't edit the same file.
Although Subversion automatically does such a merge on the server if different files are edited, in Git you must merge the commits locally.
John has to fetch Jessica's changes and merge them in before he will be allowed to push:

[source,console]
-----
$ git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -> origin/master
-----

At this point, John's local repository looks something like this:

.John's divergent history.
image::images/small-team-1.png[John's divergent history.]

John has a reference to the changes Jessica pushed up, but he has to merge them into his own work before he is allowed to push:

[source,console]
-----
$ git merge origin/master
Merge made by recursive.
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
-----

The merge goes smoothly – John's commit history now looks like this:

.John's repository after merging `origin/master`.
image::images/small-team-2.png[John's repository after merging `origin/master`.]

Now, John can test his code to make sure it still works properly, and then he can push his new merged work up to the server:

[source,console]
-----
$ git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -> master
-----

Finally, John's commit history looks like this:

.John's history after pushing to the `origin` server.
image::images/small-team-3.png[John's history after pushing to the `origin` server.]

In the meantime, Jessica has been working on a topic branch.
She's created a topic branch called `issue54` and done three commits on that branch.
She hasn't fetched John's changes yet, so her commit history looks like this:

.Jessica's topic branch.
image::images/small-team-4.png[Jessica's topic branch.]

Jessica wants to sync up with John, so she fetches:

[source,console]
-----
# Jessica's Machine
$ git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -> origin/master
-----

That pulls down the work John has pushed up in the meantime.
Jessica's history now looks like this:

.Jessica's history after fetching John's changes.
image::images/small-team-5.png[Jessica's history after fetching John's changes.]

Jessica thinks her topic branch is ready, but she wants to know what she has to merge into her work so that she can push.
She runs `git log` to find out:

[source,console]
-----
$ git log --no-merges issue54..origin/master
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith <jsmith@example.com>
Date:   Fri May 29 16:01:27 2009 -0700

   removed invalid default value
-----

The `issue54..origin/master` syntax is a log filter that asks Git to only show the list of commits that are on the latter branch (in this case `origin/master`) that are not on the first branch (in this case `issue54`). We'll go over this syntax in detail in <<_commit_ranges>>.

For now, we can see from the output that there is a single commit that John has made that Jessica has not merged in. If she merges `origin/master`, that is the single commit that will modify her local work.

Now, Jessica can merge her topic work into her master branch, merge John's work (`origin/master`) into her `master` branch, and then push back to the server again.
First, she switches back to her master branch to integrate all this work:

[source,console]
-----
$ git checkout master
Switched to branch 'master'
Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.
-----

She can merge either `origin/master` or `issue54` first – they're both upstream, so the order doesn't matter.
The end snapshot should be identical no matter which order she chooses; only the history will be slightly different.
She chooses to merge in `issue54` first:

[source,console]
-----
$ git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletions(-)
-----

No problems occur; as you can see it was a simple fast-forward.
Now Jessica merges in John's work (`origin/master`):

[source,console]
-----
$ git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)
-----

Everything merges cleanly, and Jessica's history looks like this:

.Jessica's history after merging John's changes.
image::images/small-team-6.png[Jessica's history after merging John's changes.]

Now `origin/master` is reachable from Jessica's `master` branch, so she should be able to successfully push (assuming John hasn't pushed again in the meantime):

[source,console]
-----
$ git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -> master
-----

Each developer has committed a few times and merged each other's work successfully.

.Jessica's history after pushing all changes back to the server.
image::images/small-team-7.png[Jessica's history after pushing all changes back to the server.]

That is one of the simplest workflows.
You work for a while, generally in a topic branch, and merge into your master branch when it's ready to be integrated.
When you want to share that work, you merge it into your own master branch, then fetch and merge `origin/master` if it has changed, and finally push to the `master` branch on the server.
The general sequence is something like this:

.General sequence of events for a simple multiple-developer Git workflow.
image::images/small-team-flow.png[General sequence of events for a simple multiple-developer Git workflow.]

==== Private Managed Team

(((contributing, private managed team)))
In this next scenario, you'll look at contributor roles in a larger private group.
You'll learn how to work in an environment where small groups collaborate on features and then those team-based contributions are integrated by another party.

Let's say that John and Jessica are working together on one feature, while Jessica and Josie are working on a second.
In this case, the company is using a type of integration-manager workflow where the work of the individual groups is integrated only by certain engineers, and the `master` branch of the main repo can be updated only by those engineers.
In this scenario, all work is done in team-based branches and pulled together by the integrators later.

Let's follow Jessica's workflow as she works on her two features, collaborating in parallel with two different developers in this environment.
Assuming she already has her repository cloned, she decides to work on `featureA` first.
She creates a new branch for the feature and does some work on it there:

[source,console]
-----
# Jessica's Machine
$ git checkout -b featureA
Switched to a new branch 'featureA'
$ vim lib/simplegit.rb
$ git commit -am 'add limit to log function'
[featureA 3300904] add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)
-----

At this point, she needs to share her work with John, so she pushes her `featureA` branch commits up to the server.
Jessica doesn't have push access to the `master` branch – only the integrators do – so she has to push to another branch in order to collaborate with John:

[source,console]
-----
$ git push -u origin featureA
...
To jessica@githost:simplegit.git
 * [new branch]      featureA -> featureA
-----

Jessica e-mails John to tell him that she's pushed some work into a branch named `featureA` and he can look at it now.
While she waits for feedback from John, Jessica decides to start working on `featureB` with Josie.
To begin, she starts a new feature branch, basing it off the server's `master` branch:

[source,console]
-----
# Jessica's Machine
$ git fetch origin
$ git checkout -b featureB origin/master
Switched to a new branch 'featureB'
-----

Now, Jessica makes a couple of commits on the `featureB` branch:

[source,console]
-----
$ vim lib/simplegit.rb
$ git commit -am 'made the ls-tree function recursive'
[featureB e5b0fdc] made the ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
$ vim lib/simplegit.rb
$ git commit -am 'add ls-files'
[featureB 8512791] add ls-files
 1 files changed, 5 insertions(+), 0 deletions(-)
-----

Jessica's repository looks like this:

.Jessica's initial commit history.
image::images/managed-team-1.png[Jessica's initial commit history.]

She's ready to push up her work, but gets an e-mail from Josie that a branch with some initial work on it was already pushed to the server as `featureBee`.
Jessica first needs to merge those changes in with her own before she can push to the server.
She can then fetch Josie's changes down with `git fetch`:

[source,console]
-----
$ git fetch origin
...
From jessica@githost:simplegit
 * [new branch]      featureBee -> origin/featureBee
-----

Jessica ahora puede fusionar esto en el trabajo que hizo con `git merge`:

[source,console]
-----
$ git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)
-----

Existe un pequeño problema: necesita insertar el trabajo combinado en su rama `featureB` en la rama` featureBee` del servidor.
Ella puede hacerlo especificando la rama local seguida de dos puntos (:) seguido de la rama remota al comando `git push`:

[source,console]
-----
$ git push -u origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -> featureBee
-----

Esto se llama _refspec_.
Ver << _ refspec >> para una discusión más detallada de las referencias de Git y diferentes cosas que puedes hacer con ellas.
También observe la bandera `-u`; esto es la abreviatura de `--set-upstream`, que configura las ramas para empujar y tirar más fácilmente más tarde.

Luego, John envía un correo electrónico a Jessica para decirle que ha enviado algunos cambios a la rama `featureA` y le pide que los verifique.
Ella ejecuta un `git fetch` para bajar esos cambios:

[source,console]
-----
$ git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA   -> origin/featureA
-----

Luego, ella puede ver qué se ha cambiado con `git log`:

[source,console]
-----
$ git log featureA..origin/featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith <jsmith@example.com>
Date:   Fri May 29 19:57:33 2009 -0700

    changed log output to 30 from 25
-----

Finalmente, fusiona el trabajo de John en su propia rama `featureA`:

[source,console]
-----
$ git checkout featureA
Switched to branch 'featureA'
$ git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)
-----

Jessica quiere modificar algo, por lo que se compromete de nuevo y luego lo envía de vuelta al servidor:

[source,console]
-----
$ git commit -am 'small tweak'
[featureA 774b3ed] small tweak
 1 files changed, 1 insertions(+), 1 deletions(-)
$ git push
...
To jessica@githost:simplegit.git
   3300904..774b3ed  featureA -> featureA
-----

El historial de compromiso de Jessica ahora se ve así:

.Jessica's history after committing on a feature branch.
image::images/managed-team-2.png[Jessica's history after committing on a feature branch.]

Jessica, Josie y John informan a los integradores que las ramas `featureA` y` featureBee` en el servidor están listas para su integración en la línea principal.
Después de que los integradores fusionen estas ramas en la línea principal, una búsqueda reducirá la nueva confirmación de fusión, haciendo que el historial se vea así:

.Jessica's history after merging both her topic branches.
image::images/managed-team-3.png[Jessica's history after merging both her topic branches.]

Muchos grupos cambian a Git debido a esta capacidad de tener varios equipos trabajando en paralelo, fusionando las diferentes líneas de trabajo al final del proceso.
La capacidad de los subgrupos más pequeños de un equipo para colaborar a través de sucursales remotas sin necesariamente tener que involucrar o impedir a todo el equipo es un gran beneficio de Git.
La secuencia del flujo de trabajo que vio aquí es algo como esto:

.Basic sequence of this managed-team workflow.
image::images/managed-team-flow.png[Basic sequence of this managed-team workflow.]

[[_public_project]]
==== Proyecto público bifurcado

(((contributing, public small project)))
Contribuir a proyectos públicos es un poco diferente.
Como no tiene los permisos para actualizar directamente las ramas en el proyecto, debe obtener el trabajo de otra manera.
Este primer ejemplo describe la contribución mediante bifurcación en hosts Git que admiten bifurcación fácil.
Muchos sitios de alojamiento admiten esto (incluidos GitHub, BitBucket, Google Code, repo.or.cz y otros), y muchos mantenedores de proyectos esperan este estilo de contribución.
La siguiente sección trata de proyectos que prefieren aceptar parches contribuidos por correo electrónico.

En primer lugar, es probable que desee clonar el repositorio principal, crear una rama de tema para el parche o la serie de parches que planea contribuir y hacer su trabajo allí.
La secuencia se ve básicamente así:

[source,console]
-----
$ git clone (url)
$ cd project
$ git checkout -b featureA
# (work)
$ git commit
# (work)
$ git commit
-----

[NOTA]
====
Puede usar `rebase -i` para reducir su trabajo a una única confirmación, o reorganizar el trabajo en las confirmaciones para que el desarrollador pueda revisar el parche más fácilmente. Consulte << _ rewriting_history >> para obtener más información sobre el rebase interactivo. 
====

Cuando finalice el trabajo de sucursal y esté listo para contribuir con los mantenedores, vaya a la página original del proyecto y haga clic en el botón `` Tenedor '', creando su propio tenedor escribible del proyecto.
Luego debe agregar este nuevo URL de repositorio como segundo control remoto, en este caso llamado `myfork`:

[source,console]
-----
$ git remote add myfork (url)
-----

Entonces necesitas impulsar tu trabajo hasta eso.
Es más fácil impulsar la rama de tema en la que está trabajando hasta su repositorio, en lugar de fusionarse con su rama principal y aumentarla.
La razón es que si el trabajo no se acepta o se selecciona con una cereza, no es necesario rebobinar la rama maestra.
Si los mantenedores se fusionan, redimensionan o seleccionan su trabajo, eventualmente lo recuperará a través de su repositorio de todas maneras:

[source,console]
-----
$ git push -u myfork featureA
-----

(((git commands, request-pull)))
Cuando su trabajo ha sido empujado hacia su tenedor, debe notificar al mantenedor.
Esto a menudo se denomina solicitud de extracción, y puedes generarlo a través del sitio web: GitHub tiene su propio mecanismo de solicitud de extracción que veremos en << _ github >> o puedes ejecutar el comando `git request-pull` y envíe por correo electrónico la salida al mantenedor del proyecto de forma manual.

El comando `request-pull` toma la rama base en la que desea que se saque su rama de tema y la URL del repositorio de Git de la que desea que extraigan, y genera un resumen de todos los cambios que está solicitando.
Por ejemplo, si Jessica quiere enviar a John una solicitud de extracción, y ella ha hecho dos commits en la rama de temas que acaba de subir, puede ejecutar esto:

[source,console]
-----
$ git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
  John Smith (1):
        added a new function

are available in the git repository at:

  git://githost/simplegit.git featureA

Jessica Smith (2):
      add limit to log function
      change log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)
-----

La salida se puede enviar al mantenedor, les dice de dónde se ramificó el trabajo, resume los compromisos y dice de dónde sacar este trabajo.

En un proyecto para el cual no eres el mantenedor, generalmente es más fácil tener una rama como `master` siempre rastrea` origin / master` y hacer tu trabajo en ramas de tema que puedes descartar fácilmente si son rechazadas.
Tener temas de trabajo aislados en las ramas temáticas también facilita la tarea de volver a establecer una base de trabajo si la punta del repositorio principal se ha movido mientras tanto y sus confirmaciones ya no se aplican limpiamente.
Por ejemplo, si desea enviar un segundo tema de trabajo al proyecto, no continúe trabajando en la rama de tema que acaba de crear: vuelva a comenzar desde la rama `master` del repositorio principal:

[source,console]
-----
$ git checkout -b featureB origin/master
# (work)
$ git commit
$ git push myfork featureB
# (email maintainer)
$ git fetch origin
-----

Ahora, cada uno de sus temas está contenido dentro de un silo, similar a una fila de parches, que puede volver a escribir, volver a establecer y modificar sin que los temas interfieran o se interrelacionen entre sí, de la siguiente manera:

.Initial commit history with `featureB` work.
image::images/public-small-1.png[Initial commit history with `featureB` work.]

Digamos que el mantenedor del proyecto ha sacado otros parches y ha probado su primera sucursal, pero ya no se fusiona de manera limpia.
En este caso, puede tratar de volver a establecer la base de esa rama sobre 'origin / master', resolver los conflictos del mantenedor y luego volver a enviar los cambios:

[source,console]
-----
$ git checkout featureA
$ git rebase origin/master
$ git push -f myfork featureA
-----

Esto reescribe tu historial para que ahora parezca << psp_b >>.

[[psp_b]]
.Commit history after `featureA` work.
image::images/public-small-2.png[Commit history after `featureA` work.]

Debido a que rebasaste la rama, debes especificar el `-f` en tu comando push para poder reemplazar la rama` featureA` en el servidor con una confirmación que no sea un descendiente de ella.
Una alternativa sería llevar este nuevo trabajo a una rama diferente en el servidor (tal vez llamada `featureAv2`).

Veamos un escenario más posible: el mantenedor ha observado el trabajo en su segunda sucursal y le gusta el concepto, pero le gustaría que cambie un detalle de implementación.
También aprovechará esta oportunidad para mover el trabajo basado en la rama `maestra 'actual del proyecto.
Usted inicia una nueva sucursal basada en la rama actual de 'origen / maestro', aplasta los cambios `featureB` allí, resuelve cualquier conflicto, hace que la implementación cambie, y luego lo empuja hacia arriba como una nueva sucursal:

(((git commands, merge, squash)))
[source,console]
-----
$ git checkout -b featureBv2 origin/master
$ git merge --no-commit --squash featureB
# (change implementation)
$ git commit
$ git push myfork featureBv2
-----

The `--squash` option takes all the work on the merged branch and squashes it into one non-merge commit on top of the branch you're on.
The `--no-commit` option tells Git not to automatically record a commit.
This allows you to introduce all the changes from another branch and then make more changes before recording the new commit.

Now you can send the maintainer a message that you've made the requested changes and they can find those changes in your `featureBv2` branch.

.Commit history after `featureBv2` work.
image::images/public-small-3.png[Commit history after `featureBv2` work.]

[[_project_over_email]]
==== Public Project over E-Mail

(((contributing, public large project)))
Many projects have established procedures for accepting patches – you'll need to check the specific rules for each project, because they will differ.
Since there are several older, larger projects which accept patches via a developer mailing list, we'll go over an example of that now.

The workflow is similar to the previous use case – you create topic branches for each patch series you work on.
The difference is how you submit them to the project.
Instead of forking the project and pushing to your own writable version, you generate e-mail versions of each commit series and e-mail them to the developer mailing list:

[source,console]
-----
$ git checkout -b topicA
# (work)
$ git commit
# (work)
$ git commit
-----

(((git commands, format-patch)))
Now you have two commits that you want to send to the mailing list.
You use `git format-patch` to generate the mbox-formatted files that you can e-mail to the list – it turns each commit into an e-mail message with the first line of the commit message as the subject and the rest of the message plus the patch that the commit introduces as the body.
The nice thing about this is that applying a patch from an e-mail generated with `format-patch` preserves all the commit information properly.

[source,console]
-----
$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
-----

The `format-patch` command prints out the names of the patch files it creates.
The `-M` switch tells Git to look for renames.
The files end up looking like this:

[source,console]
-----
$ cat 0001-add-limit-to-log-function.patch
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith <jessica@example.com>
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = 'master')
-    command("git log #{treeish}")
+    command("git log -n 20 #{treeish}")
   end

   def ls_tree(treeish = 'master')
--
2.1.0
-----

You can also edit these patch files to add more information for the e-mail list that you don't want to show up in the commit message.
If you add text between the `---` line and the beginning of the patch (the `diff --git` line), then developers can read it; but applying the patch excludes it.

To e-mail this to a mailing list, you can either paste the file into your e-mail program or send it via a command-line program.
Pasting the text often causes formatting issues, especially with ``smarter'' clients that don't preserve newlines and other whitespace appropriately.
Luckily, Git provides a tool to help you send properly formatted patches via IMAP, which may be easier for you.
We'll demonstrate how to send a patch via Gmail, which happens to be the e-mail agent we know best; you can read detailed instructions for a number of mail programs at the end of the aforementioned `Documentation/SubmittingPatches` file in the Git source code.

(((git commands, config)))(((email)))
First, you need to set up the imap section in your `~/.gitconfig` file.
You can set each value separately with a series of `git config` commands, or you can add them manually, but in the end your config file should look something like this:

[source,ini]
-----
[imap]
  folder = "[Gmail]/Drafts"
  host = imaps://imap.gmail.com
  user = user@gmail.com
  pass = p4ssw0rd
  port = 993
  sslverify = false
-----

If your IMAP server doesn't use SSL, the last two lines probably aren't necessary, and the host value will be `imap://` instead of `imaps://`.
When that is set up, you can use `git send-email` to place the patch series in the Drafts folder of the specified IMAP server:

[source,console]
-----
$ git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith <jessica@example.com>]
Emails will be sent from: Jessica Smith <jessica@example.com>
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y
-----

Then, Git spits out a bunch of log information looking something like this for each patch you're sending:

[source,text]
-----
(mbox) Adding cc: Jessica Smith <jessica@example.com> from
  \line 'From: Jessica Smith <jessica@example.com>'
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith <jessica@example.com>
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: <1243715356-61726-1-git-send-email-jessica@example.com>
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: <y>
References: <y>

Result: OK
-----

At this point, you should be able to go to your Drafts folder, change the To field to the mailing list you're sending the patch to, possibly CC the maintainer or person responsible for that section, and send it off.

==== Summary

This section has covered a number of common workflows for dealing with several very different types of Git projects you're likely to encounter, and introduced a couple of new tools to help you manage this process.
Next, you'll see how to work the other side of the coin: maintaining a Git project.
You'll learn how to be a benevolent dictator or integration manager.
