[[_git_reset]]
=== Reset Demystified

lo básico antes de entrar en herramientas más complicadas, hablemos de `reset` y `checkout`.
Estos comandos son dos de las partes más complejas de Git cuando te encuentras con ellos por primera vez.
Tienen tantas acciones que parece imposible entenderlas y emplearlas adecuadamente.
Para ello, recomendamos una simple táctica. 

==== Los tres árboles

Una manera más fácil de entender  en 'RESET' y 'Checkout' es a través del marco mental de Git es un gestor de contenidos de tres árboles diferentes.
Por ''tree'' aquí que realmente queremos decir ''colección de archivos'', no específicamente la estructura de datos.
(Existen algunos casos en los que el index no actúa exactamente como un árbol, pero para nuestros objetivos es mas sencillo imaginarlo así por ahora).

Git como sistema gestiona y manipula tres árboles en su funcionamiento normal:

[cols="1,2",options="header"]
|================================
| Tree              | Role
| HEAD              | Last commit snapshot, next parent
| Index             | Proposed next commit snapshot
| Working Directory | Sandbox
|================================

===== the head
HEAD es el indicador de la actual branch, que a su vez es un indicador del ultimo commit realizado en ese branch.
Eso significa que HEAD será el padre del próximo commit que se cree.
Generalmente es más sencillo pensar que HEAD es snapshot *del ultimo commit*.

De hecho, es mucho mas fácil entender cómo se ve ese snapshot.
Aquí hay un ejemplo de cómo obtener el listado actual de directorios y las sumas de comprobación SHA-1 para cada archivo en el directorio. HEAD snapshot:

[source,console]
----
$ git cat-file -p HEAD
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
author Scott Chacon  1301511835 -0700
committer Scott Chacon  1301511835 -0700

initial commit

$ git ls-tree -r HEAD
100644 blob a906cb2a4a904a152...   README
100644 blob 8f94139338f9404f2...   Rakefile
040000 tree 99f1a6d12cb4b6f19...   lib
----

Los comandos `cat-file` y `ls-tree` son comandos de instalación que se utilizan para tareas de nivel bajo y no se usan realmente en el trabajo diario, pero nos ayudan a ver lo que está pasando en este caso.

[[_the_index]]
===== The Index

El índice es su *de próximo commit*. También nos hemos estado refiriendo a este concepto como el ``Área de estado'' de Git, ya que esto es lo que Git ve cuando ejecutas `commit Git`'..

Git llena este índice con una lista de todo el contenido del archivo que quedo vulnerable por última vez en su directorio de trabajo y lo que parecía cuando fueron originalmente desprotegido.
Usted entonces puede sustituir algunos de esos archivos con nuevas versiones de Git, y 'commit' lo convierte en el árbol con un new commit.

[source,console]
----
$ git ls-files -s
100644 a906cb2a4a904a152e80877d4088654daad0c859 0	README
100644 8f94139338f9404f26296befa88755fc2598c289 0	Rakefile
100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0	lib/simplegit.rb
----

De nuevo, aquí estamos usando 'ls-files", que no es más que un comando detrás de las escenas que muestra lo que su índice actualmente parece.

El índice no es técnicamente una estructura de árbol - en realidad se implementa como un documento de manifiesto - pero para nuestros fines está lo suficientemente cerca.

===== El directorio de trabajo.

Por último, usted tiene su directorio de trabajo.
Los otros dos árboles almacenan su contenido de una manera eficiente pero incomoda, dentro de la carpeta `. git`.
El directorio de trabajo los descomprime en archivos de datos reales, lo que facilita enormemente su edición.
Piense en el Directorio de trabajo como un *sandbox*, donde puede ensayar los cambios antes de confirmarlos a su área de montaje (índice) y luego al historial.

[source,console]
----
$ tree
.
├── README
├── Rakefile
└── lib
    └── simplegit.rb

1 directory, 3 files
----

==== Flujo de trabajo
Su objetivo principal es git para grabar snapshots del proyecto mejor sucesivamente en los estados, mediante la manipulación de estos tres árboles.

image::images/reset-workflow.png[]

Visualicemos este proceso: digamos que usted entra en un nuevo directorio con un solo archivo dentro.
Llamaremos a esto *v1* del archivo, y lo indicaremos en azul.
Ahora ejecutaremos `git init`, que creará un repositorio Git con una referencia HEAD que apunta nueva branch (`master` doesn't exist yet).

image::images/reset-ex1.png[]

En este punto, sólo el árbol Directorio de trabajo tiene contenido.

Ahora queremos confirmar este archivo, así que usamos `git add` para tomar la información del directorio de trabajo y copiarla al índice.

image::images/reset-ex2.png[]

Luego ejecutaremos `git commit`, que toma el contenido del Índice y lo guarda como una snapshot permanente, crea un objeto del commit que apunta a esa snapshot, y actualiza `master` para apuntar a ese commit.

image::images/reset-ex3.png[]

Si ejecutamos el `git statust', no veremos ningún cambio, porque los tres árboles son iguales.
Ahora queremos hacer un cambio en ese archivo y confirmarlo.
Lo haremos con el mismo proceso; primero cambiamos el archivo en nuestro directorio de trabajo.
Llamemos a esto *v2* del archivo, e indiquémoslo en rojo.

image::images/reset-ex4.png[]

Si ejecutamos `git status` ahora mismo, veremos el archivo en rojo como ``Cambios no montados para confirmación'', porque esa opción difiere entre el índice y el directorio de trabajo.
A continuación ejecutaremos `git add` en él para colocarlo en nuestro Índice.

image::images/reset-ex5.png[]

En este punto si ejecutamos `git status` veremos el archivo en verde
bajo ```Changes to be committed'' porque el Índice y la CABEZA difieren - es decir, nuestro próximo commit propuesto es ahora diferente de nuestro último commit.
Finalmente, ejecutaremos "Git commit" para finalizar la confirmación.

image::images/reset-ex6.png[]

Ahora `git status' no nos dará ninguna respuesta, porque los tres árboles son los mismos de nuevo.
Ramas de conmutación o clonación pasa por un proceso similar.
Cuando verificamos la  branch, esta cambia*HEAD*Para que apunte a la nueva rama ref, satura tu *Index* con un snapshot de ese commit , a continuación, copia el contenido de la*Index* dentro del *Working Directory*.

==== La función de restablecimiento

El comando `reset`tiene más importancia en este contexto.

Para los fines de estos ejemplos, digamos que hemos modificado `file.txt` y lo ha cometido por tercera vez. Así que ahora nuestro historial es así:

image::images/reset-start.png[]

Ahora vamos a repasar exactamente lo que hace `reset' cuando lo ejecutas. Manipula directamente estos tres árboles de forma sencilla y predecible.
Realiza hasta tres operaciones básicas

===== Paso 1: Move HEAD

Lo primero que `reset` hará es mover lo que HEAD indica.
Este no es el mismo como el cabezal de cambio en sí mismo (que es lo que 'Checkout'); 'RESET' mueve la rama a la que está apuntando a la cabeza
Esto significa que si HEAD está configurado en la rama `master` (es decir, si está actualmente en la rama `master), ejecutando `git reset 9e5e64a` comenzará haciendo que el ítem `master` apunte a `9e5e64a`.

image::images/reset-soft.png[]

Independientemente de la fórmula de `reset` con un commit que realices, esta es la primera acción que siempre intentará hacer.
Con `reset --soft`, simplemente se quedará allí.

Ahora tómese un segundo para mirar ese diagrama y darse cuenta de lo que pasó: esencialmente se deshizo el último comando `git commit`.
Cuando ejecutamos`git commit`, Git crea un nuevo commit y mueve  la branch que HEAD apunta a ello.
Cuando hacemos `reset` de vuelta a  `HEAD~` (the parent of HEAD), está moviendo la branch de nuevo a donde estaba, sin cambiar el índice o directorio de trabajo.
Ahora podría actualizar el Índice y ejecutar `Git commit` de nuevo para lograr lo que `git commit --amend` habría hecho (ver <<<_git_amend>>>).
===== Paso 2: Actualización del índice (--mixed)

Tenga en cuenta que si ejecuta `git status` ahora verá en verde la diferencia entre el índice y lo que es el nuevo HEAD.
Lo siguiente que `reset` hará es actualizar el Índice con el contenido de cualquier capturaa la que HEAD ahora apunte.

image::images/reset-mixed.png[]

Si usted especifica la opción "--mixed", `reset` se terminará en este instante.
Éste es el valor predeterminado, así que si no especifica ninguna opción en absoluto (sólo `git reset HEAD~` en este caso), aquí es donde se parará el comando.
Ahora tómese un segundo más para mirar ese diagrama y darse cuenta de lo que pasó: todavía se deshizo su último `commit`, pero también _unstaged_  todo.Volviste atrás antes de ejecutar todos los comandos `git add` y `git commit`.
===== Paso3: Actualizar el directorio de trabajo. (--hard)

La tercera acción que `reset` hará es hacer que el Directorio de Trabajo se parezca al Índice.
Si usas la opción `--hard` continuará hasta esta fase.

image::images/reset-hard.png[]
Así que pensemos en lo que acaba de pasar.
Deshiciste tu último commit, los comandos `git add` y `git commit`, **and** todo el trabajo que hiciste en tu directorio de trabajo

Es importante tener en cuenta que esta bandera (`--hard`) Es la única manera de hacer que el comando 'reset' peligroso, y uno de los pocos casos en que Git se destruyen.
Cualquier otra opción de `reset` puede se masfácil de deshacer, pero la opción `--hard` no puede, ya que sobrescribe por la fuerza los archivos en el directorio de trabajo.
En este caso en particular, todavía tenemos la versión *v3* de nuestro archivo en un commit en nuestra Git DB, y podríamos recuperarla mirando nuestro `reflog`, pero si no lo hubiéramos hecho, Git aún así habría sobrescrito el archivo y sería irrecuperable.

===== Recapitulation

El comando`reset` sobreescribe estos tres árboles en un orden específico, deteniéndose cuando se lo diga:
1. Move the branch HEAD points to _(stop here if `--soft`)_
2. Make the Index look like HEAD _(stop here unless `--hard`)_
3. Make the Working Directory look like the Index

==== Restablecer con una ruta
Que cubre el comportamiento de 'reset' en su forma básica, pero también puede proporcionar una ruta para actuar.
Si se especifica una ruta, 'RESET' se omite el paso 1, y limita el resto de sus acciones a un determinado archivo o conjunto de archivos.
Esta especie de sentido -jefe es sólo un puntero y no puede apuntar a parte de cometer uno y parte de otro.
Pero el índice y el directorio de trabajo _puede_ ser parcialmente actualizado, a fin de restablecer continúa con los pasos 2 y 3.

Por lo tanto, asumimos que ejecute `git reset file.txt`.
Este formulario (ya que no se especifique un commit SHA-1 o rama, y usted no especifique '--soft' o '--hard') es una abreviación para "git reset --mixed jefe archivo.txt', que verá:

1.Mover la rama HEAD apunta a_(skipped)_
2.Hacerque el índice mire como cabeza _(stop here)_

Así que esencialmente sólo copias 'file.txt' desde la cabeza hasta el índice.

image::images/reset-path1.png[]

Esto tiene el efecto práctico de _unstaging_ el archivo.
Si observamos el diagrama para ese comando y pensamos en lo que hace `git add`, son exactamente opuestos.

image::images/reset-path2.png[]

Esta es la razón por la que la imagen del comando `git status` sugiere que ejecute este comando para descomprimir un archivo.
(Para más información, consulte <<_unstaging>>.)

Podríamos fácilmente no dejar que Git asumiera que nos referíamos a ``pull the data from HEAD'' especificando un commit específico para extraer esa copia.
Simplemente ejecutaríamos algo como `git reset eb43bf archivo. txt`.

image::images/reset-path3.png[]

Esto efectivamente hace lo mismo que si hubiéramos devuelto el contenido del archivo a *v1* en el directorio de trabajo, ejecutado `git add` en él, luego lo ha vuelto a *v3* otra vez (sin pasar por todos esos pasos).
Si ejecutamos `git commit` ahora, grabará un cambio que revierte ese archivo a *v1*, aunque nunca lo hayamos vuelto a tener en nuestro directorio de trabajo..
También es interesante observar que como 'git add', el comando 'reset' aceptará un '--patch' opción para unstage contenido pieza por pieza.
Así que usted puede selectivamente o unstage recuperar contenido.

==== Compresión

Veamos cómo hacer algo interesante con este nuevo poder: comprimir los commits.

Digamos que tienes una serie de commits con mensajes como "oops"."WIP" y ``forgot this file''.
Puedes usar `reset` para encajarlas rápida y fácilmente en un único commit que te hace lucir realmente inteligente.
(<<<_squashing>> muestra otra forma de hacer esto, pero en este ejemplo es más sencillo usar `reset`).

Digamos que tienes un proyecto donde la primer commit tiene un archivo, El Segundo commit agregó un nuevo archivo y cambió el primero, y el tercer commit cambió el primer archivo nuevamente.
El segundo commit fue un trabajo en progreso y quieres darle de baja.

image::images/reset-squash-r1.png[]

Puede ejecutar`git reset --soft HEAD~2` para mover la rama HEAD de vuelta al commit anterior  (manteniendo el primer commit):

image::images/reset-squash-r2.png[]

Y luego simplemente ejecutar`git commit`de nuevo:

image::images/reset-squash-r3.png[]

Ahora puedes ver que tu historial accesible, el historial que quieres, ahora parece que tuviste un commit con `file-a. txt` v1, luego un segundo que modificó `file-a. txt` a v3 y agregó `file-b. txt`. el commit  con la versión v2 del archivo ya no está en el historial.


==== Compruébelo

Finalmente, usted puede preguntarse cuál es la diferencia entre 'Checkout' y 'reset'.
Como 'RESET', 'Checkout' manipula los tres árboles, y es un poco distinto dependiendo del comando a la ruta de un archivo o no.

===== Sin rutas

Ejecutar `git checkout[branch]` es muy similar a ejecutar `git reset --hard[branch]` en que actualiza los tres árboles para que parezca `[branch]`, pero hay dos diferencias importantes.
En primer lugar, a diferencia de `reset --hard`, `checkout` es seguro en el directorio de trabajo; se comprobará para asegurarse de que no está destruyendo archivos que tienen cambios.
En realidad, es un poco más inteligente que eso - trata de hacer una fusión trivial en el Directorio de Trabajo, por lo que todos los archivos en los que no has cambiado se actualizarán.
``reset --hard`, por otro lado, simplemente reemplazará todo a través de la placa sin chequear.

La segunda diferencia importante es cómo actualiza HEAD.
Donde `reset` moverá la rama a la que HEAD apunta, `checkout` moverá HEAD para apuntar a otra rama.

Por ejemplo, digamos que tenemos ramas `master` y `develop` que apuntan a diferentes commits, y actualmente estamos en`develop` (entonces HEAD lo apunta).
Si ejecutamos `git reset master`, `develop` ahora mismo indicará la misma confirmación que hace `master`.
Si en su lugar ejecutamos `git checkout master`, `develop` no se mueve, HEAD lo hace.
HEAD ahora apuntará a`master`.

Así que, en ambos casos estamos moviendo HEAD para apuntar al commit  A, pero _cómo lo hacemos es muy diferente.
`reset` moverá la rama HEAD apunta a, `checkout` se movera a HEAD.

image::images/reset-checkout.png[]

===== Con trazados

La otra forma de ejecutar 'Checkout' es con la ruta de acceso de un archivo, el cual, como 'reset', no mueve a head.
Es como el`git reset [branch] file`  en el sentido de que actualiza el índice con ese archivo en la confirmación, pero también sobreescribe el archivo en el directorio de trabajo.
Sería exactamente como`git reset --hard [branch] file` de archivo` (si `reset` te dejaría ejecutarlo) - no es seguro para el directorio de trabajo, y no mueve HEAD.

También, como`git reset` y "`git add`,`checkout` aceptará una opción "--patch" para permitirle revertir selectivamente el contenido de los archivos en una base hunk-by-hunk.

==== Resumen

Esperemos que ahora usted entienda y se sienta más cómodo con el comando  `reset` , pero probablemente todavía esté un poco confundido sobre cómo exactamente difiere de`checkout`y no podría recordar todas las reglas de las diferentes acciones.

Aquí está una hoja de trucos para que los comandos que afectan a los árboles.
El ‘’HEAD’’ columna dice ''REF'' si este comando mueve la referencia (branch) que apunta a la cabeza, y ‘’HEAD’’ si se mueve la cabeza.
Rendir especial atención al "WD Seguro?' columna - Si dice *NO*, tómese unos segundos para pensar antes de ejecutar el comando.

[options="header", cols="3,1,1,1,1"]
|================================
| | HEAD | Index | Workdir | WD Safe?
| *Commit Level* | | | |
| `reset --soft [commit]` | REF | NO | NO | YES
| `reset [commit]` | REF | YES | NO | YES
| `reset --hard [commit]` | REF | YES | YES | *NO*
| `checkout [commit]` | HEAD | YES | YES | YES
| *File Level* | | | |
| `reset (commit) [file]` | NO | YES | NO | YES
| `checkout (commit) [file]` | NO | YES | YES | *NO*
|================================
