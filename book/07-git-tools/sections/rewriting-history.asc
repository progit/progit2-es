[[_rewriting_history]]
=== Rewriting History

Many times, when working with Git, you may want to revise your commit history for some reason.
One of the great things about Git is that it allows you to make decisions at the last possible moment.
You can decide what files go into which commits right before you commit with the staging area, you can decide that you didn’t mean to be working on something yet with the stash command, and you can rewrite commits that already happened so they look like they happened in a different way.
This can involve changing the order of the commits, changing messages or modifying files in a commit, squashing together or splitting apart commits, or removing commits entirely – all before you share your work with others.

In this section, you’ll cover how to accomplish these very useful tasks so that you can make your commit history look the way you want before you share it with others.

[[_git_amend]]
==== Changing the Last Commit

Changing your last commit is probably the most common rewriting of history that you’ll do.
You’ll often want to do two basic things to your last commit: change the commit message, or change the snapshot you just recorded by adding, changing and removing files.

If you only want to modify your last commit message, it’s very simple:

[source,console]
----
$ git commit --amend
----

That drops you into your text editor, which has your last commit message in it, ready for you to modify the message.
When you save and close the editor, the editor writes a new commit containing that message and makes it your new last commit.

If you’ve committed and then you want to change the snapshot you committed by adding or changing files, possibly because you forgot to add a newly created file when you originally committed, the process works basically the same way.
You stage the changes you want by editing a file and running `git add` on it or `git rm` to a tracked file, and the subsequent `git commit --amend` takes your current staging area and makes it the snapshot for the new commit.

You need to be careful with this technique because amending changes the SHA-1 of the commit.
It’s like a very small rebase – don’t amend your last commit if you’ve already pushed it.

[[_changing_multiple]]
==== Changing Multiple Commit Messages

To modify a commit that is farther back in your history, you must move to more complex tools.
Git doesn’t have a modify-history tool, but you can use the rebase tool to rebase a series of commits onto the HEAD they were originally based on instead of moving them to another one.
With the interactive rebase tool, you can then stop after each commit you want to modify and change the message, add files, or do whatever you wish.
You can run rebase interactively by adding the `-i` option to `git rebase`.
You must indicate how far back you want to rewrite commits by telling the command which commit to rebase onto.

For example, if you want to change the last three commit messages, or any of the commit messages in that group, you supply as an argument to `git rebase -i` the parent of the last commit you want to edit, which is `HEAD~2^` or `HEAD~3`.
It may be easier to remember the `~3` because you’re trying to edit the last three commits; but keep in mind that you’re actually designating four commits ago, the parent of the last commit you want to edit:

[source,console]
----
$ git rebase -i HEAD~3
----

Remember again that this is a rebasing command – every commit included in the range `HEAD~3..HEAD` will be rewritten, whether you change the message or not.
Don’t include any commit you’ve already pushed to a central server – doing so will confuse other developers by providing an alternate version of the same change.

Running this command gives you a list of commits in your text editor that looks something like this:

[source,console]
----
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
----

It’s important to note that these commits are listed in the opposite order than you normally see them using the `log` command.
If you run a `log`, you see something like this:

[source,console]
----
$ git log --pretty=format:"%h %s" HEAD~3..HEAD
a5f4a0d added cat-file
310154e updated README formatting and added blame
f7f3f6d changed my name a bit
----

Notice the reverse order.
The interactive rebase gives you a script that it’s going to run.
It will start at the commit you specify on the command line (`HEAD~3`) and replay the changes introduced in each of these commits from top to bottom.
It lists the oldest at the top, rather than the newest, because that’s the first one it will replay.

You need to edit the script so that it stops at the commit you want to edit.
To do so, change the word `pick' to the word `edit' for each of the commits you want the script to stop after.
For example, to modify only the third commit message, you change the file to look like this:

[source,console]
----
edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

When you save and exit the editor, Git rewinds you back to the last commit in that list and drops you on the command line with the following message:

[source,console]
----
$ git rebase -i HEAD~3
Stopped at f7f3f6d... changed my name a bit
You can amend the commit now, with

       git commit --amend

Once you’re satisfied with your changes, run

       git rebase --continue
----

These instructions tell you exactly what to do.
Type

[source,console]
----
$ git commit --amend
----

Change the commit message, and exit the editor.
Then, run

[source,console]
----
$ git rebase --continue
----

This command will apply the other two commits automatically, and then you’re done.
If you change pick to edit on more lines, you can repeat these steps for each commit you change to edit.
Each time, Git will stop, let you amend the commit, and continue when you’re finished.

==== Reordering Commits

You can also use interactive rebases to reorder or remove commits entirely.
If you want to remove the ``added cat-file'' commit and change the order in which the other two commits are introduced, you can change the rebase script from this

[source,console]
----
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

to this:


[source,console]
----
pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit
----

When you save and exit the editor, Git rewinds your branch to the parent of these commits, applies `310154e` and then `f7f3f6d`, and then stops.
You effectively change the order of those commits and remove the ``added cat-file'' commit completely.

[[_squashing]]
==== Squashing Commits

It’s also possible to take a series of commits and squash them down into a single commit with the interactive rebasing tool.
The script puts helpful instructions in the rebase message:

[source,console]
----
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
----

Si, en vez de ``pick'' o``edit'', especificas ``squash'', Git aplica a ambos este cambio y los cambia directamente después y hace que las confirmaciones se unan.
Entonces, si quieres convertir en una única confirmación de estas tres confirmaciones, deberás hacer que el script se vea como esto:

[source,console]
----
pick f7f3f6d changed my name a bit
squash 310154e updated README formatting and added blame
squash a5f4a0d added cat-file
----

Cuando guardes te salgas del editor, Git aplicará a los tres el cambio y después te dirigirá en el editor para fusionar los tres mensajes de la confirmación:

[source,console]
----
# This is a combination of 3 commits.
# The first commit's message is:
changed my name a bit

# This is the 2nd commit message:

updated README formatting and added blame

# This is the 3rd commit message:

added cat-file
----

Cuando guardes eso, tendrás una única confirmación que introducirá los cambios de las tres previas confirmaciones.

==== Dividiendo una confirmación 

Dividir una confirmación la deshace y después realiza etapas parcialmente de las confirmaciones tantas veces como confirmaciones desees finalizar.
Por ejemplo, suponiendo que quieres dividir la confirmación de en medio de tus  tres confirmaciones.
En vez de ``updated README formatting and added blame'', quieres dividirla en dos confirmaciones: ``updated README formatting'' para la primera, y ``added blame''para la segunda. 
Puedes hacer eso en el rebase -i` script cambiando la instruccion en la confirmacion que quieres dividir a ``edit'':

[source,console]
----
pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

¿Entonces, cuando el script te envié a la línea de comandos, tu reseteas esa confirmación, tomas los cambios que se han hecho, y creas múltiples confirmación fuera de ellas? 
Cuando guardes y salgas del editor, Git te enviará al padre de la primer confirmación en tu lista, Aplica a la primera confirmación (`f7f3f6d`), aplicando a la segunda (`310154e`) y te enviará directamente a la consola.
 Ahí, puedes hacer un reseteo mixto de esa confirmación con el `git reset HEAD^`, el que efectivamente deshace las confirmaciones en los archivos hasta que tengas.
Ahora puedes organizar y confirmar los archivos hasta que tenga varias confirmaciones y ejecutar `git rebase --continuar` cuando haya terminado:

[source,console]
----
$ git reset HEAD^
$ git add README
$ git commit -m 'updated README formatting'
$ git add lib/simplegit.rb
$ git commit -m 'added blame'
$ git rebase --continue
----

Git aplica la última confirmación (`a5f4a0d`) en el script, y tu historia quedaría de esta manera:

[source,console]
----
$ git log -4 --pretty=format:"%h %s"
1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit
----

Una vez de Nuevo, esto cambia el SHA-1s de todas tus confirmaciones en tu lista, así que asegúrate de que ninguna confirmación esté en esa lista que ya has puesto en un repositorio compartido.

==== La opción nuclear: filtrar-ramificar

Existe otra opción en la parte de volver a escribir la historia que puedes usar si necesitas reescribir un gran número de confirmaciones de una manera que se puedan scriptear – de hecho, cambiar tu dirección de e-mail o remover cualquier archivo en las confirmaciones.
El comando es `filter-branch`, y este puede reescribir una gran cantidad de franjas de su historia, así que probablemente no lo deberías usar a menos que tu proyecto aún no sea público y otra persona no se haya basado en sus confirmaciones que estás a punto de reescribir.
Como sea, podría ser muy útil.
Aprenderás unas cuantas maneras muy comunes de obtener una idea de algunas de las cosas que es capaz de hacer.

[[_removing_file_every_commit]]
===== Remover un archivo de cada confirmación 

Esto ocurre comúnmente.
Esto ocurre comúnmente. Alguien accidentalmente confirma un gran numero binario de un archivo con un irreflexivo `git add .`, y quieres removerlo de todas partes.
 Suponiendo que accidentalmente confirmaste un archivo que contenía contraseña y quieres volverlo un proyecto abierto.
`filter-branch` es la herramienta que tu probablemente quieres usar para limpiar toda tu historia. 
Para remover un archivo nombrado passwords.txt de tu historia complete puedes usar el `--tree-filter` option to `filter-branch`:

[source,console]
----
$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Ref 'refs/heads/master' was rewritten
----

El `--tree-filter` inicia el comando especifico después de cada revisión del proyecto y este entonces vuelve a confirmar los resultados.
En este caso, deberías remover el archivo llamado passwords.txt de cada instantánea, aun si existe o no.
si quieres remover todas las confirmaciones accidentales del respaldo del editor de archivos, puedes iniciar algo como el `git filter-branch --tree-filter 'rm -f *~' HEAD`.

Deberías ser capaz de ver la reescripción de confirmaciones y estructuras del Git y luego debes mover el puntero de la rama al final.
Es generalmente una buena idea hacer esto en una parte de prueba de la rama y después hacer un hard-reset de tu rama principal después de haber determinado que el resultado es lo que realmente deseas.
Para iniciar `filter-branch` en todas las ramas, puedes poner `--all` en el comando. 

===== Hacer que un subdirectorio sea la nueva raíz

Suponiendo que has hecho un importe de otro centro de Sistema de control y tienes subdirecciones que no tienen ningún sentido (tronco, etiquetas, etc). .
 Si quieres hacer que el `tronco` subdirectorio sea el nuevo proyecto de la  raíz de cada confirmación, `filter-branch`te puede ayudar a hacer eso, también: 

[source,console]
----
$ git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref 'refs/heads/master' was rewritten
----

Ahora la raíz de tu Nuevo proyecto es la que solía estar en el `tronco` subdirectorio cada vez.
Git automáticamente remueve confirmaciones que no afecten al subdirectorio.

===== Cambiar la dirección de e-mail globalmente

Otro caso comun es que olvides iniciar el git config para poner tu nombre  tu dirección de e-mail antes de que hayas empezado a trabajar, o tal vez quieres abrir un proyecto en el trabajo y cambiar todo tu e-mail de trabajo por tu e-mail personal.
De cualquier caso, puedes cambiar la dirección de e-mail en multiples confirmaciones en un lote con `filter-branch` igual.
Necesitas ser cuidadoso de cambiar solo las direcciones de e-mail que son tuyas, de manera que debes usar `--commit-filter`:

[source,console]
----
$ git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
        then
                GIT_AUTHOR_NAME="Scott Chacon";
                GIT_AUTHOR_EMAIL="schacon@example.com";
                git commit-tree "$@";
        else
                git commit-tree "$@";
        fi' HEAD
----

Esto va a traves de la reescripcion de cada confirmacion para tener tu nuva direccion. 
Por que cada confirmacion contiene el SHA-1 de sus padres, este comando cambia cada confirmacion del SHA-1 en tu historia, no solamente aquellos en los cuales el e-mail es el mismo o encaja.
