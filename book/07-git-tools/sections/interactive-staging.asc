[[r_interactive_staging]]
=== Organización interactiva

Git viene con unos cuantos scripts que hacen que algunas líneas de comando sean más fáciles de usar.
Aquí, verás unos cuantos comandos interactivos que te ayudaran a preparar tus confirmaciones para incluir sólo ciertas combinaciones y partes de los archivos.
Estás herramientas serán muy útiles si modificas unos cuantos archivos y decides que esos cambios estén en varias confirmaciones enfocadas, en lugar de en una gran confirmación problemática.
De esta manera, puedes asegurarte de que tus confirmaciones sean conjuntos de cambios lógicamente separados y que puedan ser revisados fácilmente por los desarrolladores que trabajan contigo.
Si empiezas `git add` con el `-i` o la opción `--interactive` , Git entra en un modo de celda interactiva, mostrando algo como esto:

[source,console]
----
$ git add -i
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb

*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now>
----

Puedes ver que este comando te muestra una muy diferente vista de tu área de ensayo – básicamente la misma información que con `git status`, pero un poco más sucinto e informativo.
Muestra los cambios que has realizado en la izquierda y cambios que no has hecho a la derecha.

Después de esto viene una sección de comandos.
Aquí puedes ver un sin número de cosas, incluidos los archivos organizados, archivos sin organizar, partes de archivos organizados, agregar archivos sin seguimiento y ver las diferencias de lo que se ha modificado.

==== Organizar y desorganziar archivos

Si tecleas `2` o `u` en el `What now>` rápidamente, la secuencia de comandos solicita los archivos que deseas representar:

[source,console]
----
What now> 2
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Update>>
----

Para organizar los archivos de  TODO e index.html , puedes teclear los números:

[source,console]
----
Update>> 1,2
           staged     unstaged path
* 1:    unchanged        +0/-1 TODO
* 2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Update>>
----

El `*` antes de cada archivo significa que el archivo fue seleccionado para ser organizado.
Si presionas 'Enter' después de no escribir nada en el `Update>>` rapidamente, Git toma cualquier cosa seleccionada y la organiza por ti:

[source,console]
----
Update>>
updated 2 paths

*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now> 1
           staged     unstaged path
  1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
----

Ahora puedes ver que los archivos de  TODO e index.html  han sido organizados y el archivo simplegit.rb  aún está sin organizar.
Si deseas quitar el archivo TODO en este punto, use la opción `3` o `r` (para revertir):

[source,console]
----
*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now> 3
           staged     unstaged path
  1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Revert>> 1
           staged     unstaged path
* 1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Revert>> [enter]
reverted one path
----

Mirando el estatus de tu Git de nuevo, puedes ver que has desordenado el archivo TODO:

[source,console]
----
*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now> 1
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
----

Para ver la diferencia de lo que ya has ordenado, puedes usar el comando `6` o `d` (para diferente).
Éste te muestra una lista de tus archivos organziados, y puedes seleccionar aquellos de los que quisieras ver la diferencia de su organización.
Esto es como especificar el `git diff --cached` en la línea de comando:

[source,console]
----
*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now> 6
           staged     unstaged path
  1:        +1/-1      nothing index.html
Review diff>> 1
diff --git a/index.html b/index.html
index 4d07108..4335f49 100644
--- a/index.html
+++ b/index.html
@@ -16,7 +16,7 @@ Date Finder

 <p id="out">...</p>

-<div id="footer">contact : support@github.com</div>
+<div id="footer">contact : email.support@github.com</div>

 <script type="text/javascript">
----

Con estos comandos básicos,puedes usar el modo de añadir interactivo para tratar con tu área de organización un poco más fácilmente.

==== Parches de organización

De igual manera es posible para Git, el organizar ciertas partes de archivos y no todos los demás.
Por ejemplo, si haces dos simples cambios en tu archivo simplegit.rb y quieres organizar uno pero no el otro, hacer esto es muy fácil en Git.
Desde el prompt interactivo, teclea `5` o `p` (para parche).
Git te preguntará qué archivos quieres organizar parcialmente; entonces, para cada sección de los archivos seleccionados, mostrará bloques del archivo diferencial y te preguntará si quisierás organizarlos uno por uno:

[source,console]
----
diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index dd5ecc4..57399e0 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -22,7 +22,7 @@ class SimpleGit
   end

   def log(treeish = 'master')
-    command("git log -n 25 #{treeish}")
+    command("git log -n 30 #{treeish}")
   end

   def blame(path)
Stage this hunk [y,n,a,d,/,j,J,g,e,?]?
----

Tienes muchas opciones en este punto.
Teclear `?` te mostrará una lista de lo que puedes hacer:

[source,console]
----
Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ?
y - stage this hunk
n - do not stage this hunk
a - stage this and all the remaining hunks in the file
d - do not stage this hunk nor any of the remaining hunks in the file
g - select a hunk to go to
/ - search for a hunk matching the given regex
j - leave this hunk undecided, see next undecided hunk
J - leave this hunk undecided, see next hunk
k - leave this hunk undecided, see previous undecided hunk
K - leave this hunk undecided, see previous hunk
s - split the current hunk into smaller hunks
e - manually edit the current hunk
? - print help
----

Generalmente, teclearías `y` o `n`, si quisieras organizar cada bloque, pero organizar cada uno de ellos en ciertos archivos o saltarte una decisión para algún bloque puede ser de ayuda para más tarde también.
Si organizas una parte del archivo y dejas la otra parte sin organizar, su salida de estado se verá así:

[source,console]
----
What now> 1
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:        +1/-1      nothing index.html
  3:        +1/-1        +4/-0 lib/simplegit.rb
----

El estatus del archivo simplegit.rb es interesante.
Te muestra que un par de líneas están organizadas y otro par está desorganizado.
Has organizado parcialmente este archivo.
En este punto, puedes salir del script de adición interactivo y ejecutar `git commit` para confirmar los archivos parcialmente organizados.

De igual manera, no necesitas estar en el modo de adición interactivo para hacer la organización parcial de archivos. Puedes iniciar el mismo script usando `git add -p` o `git add --patch` en la línea de comando.

Además, puede usar el modo de parche para restablecer parcialmente los archivos con el comando `reset --patch` , para verificar partes de archivos con el comando `checkout --patch` y para esconder partes de archivos con el comando `stash save --patch`. Vamos a entrar en más detalles sobre cada uno de éstos a medida que accedemos a usos más avanzados de dichos comandos.
